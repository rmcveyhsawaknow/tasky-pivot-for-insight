name: Terraform Apply and Deploy

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy
      deploy_application:
        description: 'Deploy application after infrastructure'
        required: false
        default: true
        type: boolean
  workflow_run:
    workflows: ["Terraform Plan"]
    branches: ['deploy/*']
    types:
      - completed

env:
  TF_VERSION: '1.7.5'
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  PROJECT_NAME: ${{ vars.PROJECT_NAME || 'tasky' }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT || 'dev' }}
  STACK_VERSION: ${{ vars.STACK_VERSION || 'v15' }}

permissions:
  contents: read
  id-token: write

jobs:
  check-plan-success:
    name: Check Plan Success
    runs-on: ubuntu-latest
    if: always()
    outputs:
      plan_successful: ${{ steps.check.outputs.plan_successful }}
    steps:
      - name: Check if Terraform Plan was successful or manual trigger
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "plan_successful=true" >> $GITHUB_OUTPUT
            echo "✅ Manual workflow trigger. Proceeding with apply..."
          elif [[ "${{ github.event_name }}" == "workflow_run" && "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "plan_successful=true" >> $GITHUB_OUTPUT
            echo "✅ Terraform Plan completed successfully. Proceeding with apply..."
          else
            echo "plan_successful=false" >> $GITHUB_OUTPUT
            echo "❌ Terraform Plan failed or invalid trigger. Cannot proceed with apply."
            exit 1
          fi

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [check-plan-success]
    if: needs.check-plan-success.outputs.plan_successful == 'true'
    environment: production
    outputs:
      eks_cluster_name: ${{ steps.tf_output.outputs.eks_cluster_name }}
      application_url_command: ${{ steps.tf_output.outputs.application_url_command }}
      s3_backup_url: ${{ steps.tf_output.outputs.s3_backup_url }}
      s3_backup_latest_url: ${{ steps.tf_output.outputs.s3_backup_latest_url }}
      mongodb_private_ip: ${{ steps.tf_output.outputs.mongodb_private_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Create terraform.tfvars
        run: |
          cat > terraform/terraform.tfvars << EOF
          project_name = "${{ env.PROJECT_NAME }}"
          environment = "${{ env.ENVIRONMENT }}"
          stack_version = "${{ env.STACK_VERSION }}"
          aws_region = "${{ env.AWS_REGION }}"
          mongodb_instance_type = "${{ vars.MONGODB_INSTANCE_TYPE || 't3.micro' }}"
          vpc_cidr = "${{ vars.VPC_CIDR || '10.0.0.0/16' }}"
          mongodb_username = "${{ secrets.MONGODB_USERNAME }}"
          mongodb_password = "${{ secrets.MONGODB_PASSWORD }}"
          mongodb_database_name = "${{ vars.MONGODB_DATABASE_NAME || 'go-mongodb' }}"
          jwt_secret = "${{ secrets.JWT_SECRET }}"
          EOF
          # Format the generated file immediately  
          terraform fmt terraform.tfvars
        working-directory: terraform

      - name: Terraform Init
        run: terraform init -backend-config=backend-prod.hcl
        working-directory: terraform

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: terraform

      - name: Terraform Plan (Pre-Apply Validation)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "🔍 Running pre-apply validation..."
          terraform plan -detailed-exitcode -out=tfplan
          PLAN_EXIT_CODE=$?
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "✅ No changes detected. Infrastructure is up to date."
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "📋 Changes detected. Proceeding with apply..."
          else
            echo "❌ Terraform plan failed with exit code $PLAN_EXIT_CODE"
            exit 1
          fi
        working-directory: terraform

      - name: Terraform Apply
        if: github.event.inputs.action != 'destroy'
        run: terraform apply -auto-approve tfplan
        working-directory: terraform

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve
        working-directory: terraform

      - name: Capture Terraform Outputs
        id: tf_output
        if: github.event.inputs.action != 'destroy'
        run: |
          echo "eks_cluster_name=$(terraform output -raw eks_cluster_name)" >> $GITHUB_OUTPUT
          echo "application_url_command=$(terraform output -raw application_url_command)" >> $GITHUB_OUTPUT
          echo "s3_backup_url=$(terraform output -raw s3_backup_public_url)" >> $GITHUB_OUTPUT
          echo "s3_backup_latest_url=$(terraform output -raw s3_backup_public_url_latest_db)" >> $GITHUB_OUTPUT
          echo "mongodb_private_ip=$(terraform output -raw mongodb_private_ip)" >> $GITHUB_OUTPUT
        working-directory: terraform

      - name: Infrastructure Summary
        if: github.event.inputs.action != 'destroy'
        run: |
          echo "## 🚀 Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✅ Infrastructure Components Deployed:" >> $GITHUB_STEP_SUMMARY
          echo "- **EKS Cluster**: ${{ steps.tf_output.outputs.eks_cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **MongoDB Private IP**: ${{ steps.tf_output.outputs.mongodb_private_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Backup Bucket**: ${{ steps.tf_output.outputs.s3_backup_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Latest Backup URL**: ${{ steps.tf_output.outputs.s3_backup_latest_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📋 Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Configure kubectl**: \`aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ steps.tf_output.outputs.eks_cluster_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "2. **Application deployment** will start automatically..." >> $GITHUB_STEP_SUMMARY

  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [check-plan-success, terraform-apply]
    if: |
      github.event.inputs.action != 'destroy' && 
      (github.event.inputs.deploy_application == 'true' || github.event.inputs.deploy_application == '' || github.event_name == 'workflow_run') &&
      (github.event_name == 'workflow_dispatch' || needs.check-plan-success.outputs.plan_successful == 'true')
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.terraform-apply.outputs.eks_cluster_name }}
          kubectl cluster-info

      - name: Setup ALB Controller and Deploy Application
        run: |
          chmod +x scripts/setup-alb-controller.sh
          ./scripts/setup-alb-controller.sh

      - name: Wait for Application Readiness
        run: |
          echo "⏳ Waiting for application pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=tasky -n tasky --timeout=300s
          
          echo "⏳ Waiting for ALB ingress to be ready..."
          for i in {1..30}; do
            ALB_DNS=$(kubectl get ingress tasky-ingress -n tasky -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [ -n "$ALB_DNS" ]; then
              echo "APPLICATION_URL=http://$ALB_DNS" >> $GITHUB_ENV
              break
            fi
            echo "Attempt $i/30: ALB not ready yet, waiting 30 seconds..."
            sleep 30
          done

      - name: Application Testing
        run: |
          if [ -n "$APPLICATION_URL" ]; then
            echo "🧪 Testing application accessibility..."
            
            # Test application health endpoint
            for i in {1..10}; do
              if curl -f -s "$APPLICATION_URL" > /dev/null; then
                echo "✅ Application is responding at $APPLICATION_URL"
                break
              else
                echo "Attempt $i/10: Application not ready, waiting 30 seconds..."
                sleep 30
              fi
            done
            
            # Validate MongoDB backup
            echo "🗄️ Checking MongoDB backup..."
            BACKUP_URL="${{ needs.terraform-apply.outputs.s3_backup_url }}"
            if curl -f -s -I "$BACKUP_URL" > /dev/null; then
              echo "✅ S3 backup bucket is accessible"
            else
              echo "⚠️ S3 backup bucket check failed (may be normal if no backups yet)"
            fi
          else
            echo "❌ ALB DNS name not available after waiting"
            exit 1
          fi

      - name: Deployment Summary
        run: |
          echo "## 🎉 Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🌐 Application Access:" >> $GITHUB_STEP_SUMMARY
          echo "- **Application URL**: [$APPLICATION_URL]($APPLICATION_URL)" >> $GITHUB_STEP_SUMMARY
          echo "- **Custom Domain**: Point \`ideatasky.ryanmcvey.me\` CNAME to ALB DNS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📊 Infrastructure Status:" >> $GITHUB_STEP_SUMMARY
          echo "- **EKS Cluster**: ${{ needs.terraform-apply.outputs.eks_cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **MongoDB**: Running on ${{ needs.terraform-apply.outputs.mongodb_private_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Backups**: ${{ needs.terraform-apply.outputs.s3_backup_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Latest Backup**: ${{ needs.terraform-apply.outputs.s3_backup_latest_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔧 Management Commands:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Get application URL" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.terraform-apply.outputs.application_url_command }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# View application status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods -n tasky" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# View ingress details" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get ingress tasky-ingress -n tasky" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Set Output Variables
        id: outputs
        run: |
          echo "application_url=$APPLICATION_URL" >> $GITHUB_OUTPUT
          echo "eks_cluster=${{ needs.terraform-apply.outputs.eks_cluster_name }}" >> $GITHUB_OUTPUT
